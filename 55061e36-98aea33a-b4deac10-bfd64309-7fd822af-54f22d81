local HttpService = game:GetService("HttpService")
local RbxAnalytics = game:GetService("RbxAnalyticsService")

-- Load Fluent UI Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- API Configuration
local VALIDATION_API_URL = "https://v0-remix-of-roblox-executor-system.vercel.app"
local HWID_API_URL = "https://v0-hwid-keys-website.vercel.app/api/roblox-hwids"

-- GitHub Configuration
local GITHUB_REPO = "checkurasshole/Hm45"
local GITHUB_BRANCH = "main"
local GITHUB_SOURCE = {
    name = "Number 1",
    rawUrl = "https://raw.githubusercontent.com/checkurasshole/Hm45/refs/heads/main/number1",
    filePath = "number1"
}

-- Settings
local SECRET_KEY = HttpService:GenerateGUID(false)
local MASTER_KEY = "checkdeezfuckingnuts"
local SHOW_STATS = true
local MAX_RETRIES = 3
local RETRY_DELAY = 0.5
local GITHUB_CHECK_LIMIT = 15
local HWID_API_CHECK_INTERVAL = 8
local USE_FALLBACK_API = true
local CACHE_FILE = "hwid_cache.json"
local KEY_FILE = "validation_key.dat"

-- Anti-tampering
local VALIDATION_STATE = {
    authenticated = false,
    sessionToken = nil,
    lastValidation = 0,
    tamperChecks = 0,
    failedAttempts = 0
}

local ORIGINAL_FUNCTIONS = {
    httpRequest = nil,
    HttpGet = nil
}

-- Rate limiting
local RATE_LIMIT = {
    maxAttempts = 5,
    windowSeconds = 60,
    attempts = {},
    blocked = false
}

-- Bit32 polyfill
if not bit32 then
    bit32 = {}
    function bit32.bxor(a,b)
        local res = 0
        local bitval = 1
        while a > 0 or b > 0 do
            local abit = a % 2
            local bbit = b % 2
            if (abit + bbit) % 2 == 1 then res = res + bitval end
            bitval = bitval * 2
            a = math.floor(a/2)
            b = math.floor(b/2)
        end
        return res
    end
end

-- Enhanced HTTP Request wrapper
local function httpRequest(options)
    if not ORIGINAL_FUNCTIONS.httpRequest then
        ORIGINAL_FUNCTIONS.httpRequest = request or http_request or (syn and syn.request)
    end
    
    local func = ORIGINAL_FUNCTIONS.httpRequest
    if not func then
        error("No HTTP request function found")
    end
    
    options.Headers = options.Headers or {}
    options.Headers["X-Session-Token"] = VALIDATION_STATE.sessionToken or "none"
    options.Headers["X-Client-Timestamp"] = tostring(os.time())
    
    return func(options)
end

-- Enhanced encryption
local function hashString(str)
    local hash = 0
    for i = 1, #str do
        hash = ((hash * 31) + string.byte(str, i)) % 4294967296
    end
    return string.format("%08x", hash)
end

local function generateSessionToken(clientId)
    local timestamp = tostring(os.time())
    local random = tostring(math.random(100000000, 999999999))
    local combined = clientId .. timestamp .. random .. SECRET_KEY
    return hashString(combined)
end

local function xorEncrypt(text, key)
    local result = {}
    local keyLen = #key
    for i = 1, #text do
        local textByte = string.byte(text, i)
        local keyByte = string.byte(key, ((i - 1) % keyLen) + 1)
        table.insert(result, string.char(bit32.bxor(textByte, keyByte)))
    end
    return table.concat(result)
end

local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

local function base64Encode(data)
    return ((data:gsub('.', function(x) 
        local r,bits = '', x:byte()
        for i=8,1,-1 do r = r .. (bits % 2 ^ i - bits % 2 ^ (i-1) > 0 and '1' or '0') end
        return r
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if #x < 6 then return '' end
        local c=0
        for i=1,6 do c = c*2 + (x:sub(i,i) == '1' and 1 or 0) end
        return b64chars:sub(c+1,c+1)
    end) .. ({ '', '==', '=' })[#data % 3 + 1])
end

local function base64Decode(data)
    data = string.gsub(data, '[^'..b64chars..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b64chars:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

local function encrypt(plain, key)
    local x = xorEncrypt(plain, key)
    return base64Encode(x)
end

local function decrypt(cipher_b64, key)
    local decoded = base64Decode(cipher_b64)
    return xorEncrypt(decoded, key)
end

-- Key storage
local function saveKey(key)
    if not writefile then
        warn("⚠️ File system not available")
        return false
    end
    
    local success = pcall(function()
        local sessionBound = key .. "|" .. VALIDATION_STATE.sessionToken .. "|" .. tostring(os.time())
        local encrypted = encrypt(sessionBound, MASTER_KEY)
        writefile(KEY_FILE, encrypted)
    end)
    
    return success
end

local function loadKey()
    if not isfile or not readfile then
        return nil
    end
    
    local success, result = pcall(function()
        if isfile(KEY_FILE) then
            local encrypted = readfile(KEY_FILE)
            local decrypted = decrypt(encrypted, MASTER_KEY)
            
            local parts = {}
            for part in decrypted:gmatch("[^|]+") do
                table.insert(parts, part)
            end
            
            if #parts >= 3 then
                local key = parts[1]
                local timestamp = tonumber(parts[3])
                
                if os.time() - timestamp < 86400 then
                    return key
                end
            end
        end
    end)
    
    if success and result then
        return result
    end
    
    return nil
end

local function deleteKey()
    if not delfile or not isfile then
        return false
    end
    
    local success = pcall(function()
        if isfile(KEY_FILE) then
            delfile(KEY_FILE)
        end
    end)
    
    return success
end

-- Anti-tampering
local function performTamperCheck()
    VALIDATION_STATE.tamperChecks = VALIDATION_STATE.tamperChecks + 1
    
    local currentHttpRequest = request or http_request or (syn and syn.request)
    if ORIGINAL_FUNCTIONS.httpRequest and currentHttpRequest ~= ORIGINAL_FUNCTIONS.httpRequest then
        warn("⚠️ TAMPERING DETECTED: HTTP function modified")
        return false
    end
    
    if type(VALIDATION_STATE) ~= "table" then
        warn("⚠️ TAMPERING DETECTED: State corrupted")
        return false
    end
    
    return true
end

-- Rate limiting
local function checkRateLimit()
    local currentTime = os.time()
    
    local newAttempts = {}
    for _, timestamp in ipairs(RATE_LIMIT.attempts) do
        if currentTime - timestamp < RATE_LIMIT.windowSeconds then
            table.insert(newAttempts, timestamp)
        end
    end
    RATE_LIMIT.attempts = newAttempts
    
    if #RATE_LIMIT.attempts >= RATE_LIMIT.maxAttempts then
        RATE_LIMIT.blocked = true
        return false, "Rate limit exceeded. Please wait " .. RATE_LIMIT.windowSeconds .. " seconds."
    end
    
    table.insert(RATE_LIMIT.attempts, currentTime)
    return true
end

-- Utility functions
local function trim(s)
    return (s or ""):match("^%s*(.-)%s*$") or ""
end

local function generateCacheBuster()
    local timestamp = math.floor(tick() * 1000)
    local random = math.random(100000, 999999)
    return string.format("%d_%d", timestamp, random)
end

-- Cache management
local function loadCache()
    if not isfile then
        return nil
    end
    
    local success, result = pcall(function()
        if isfile(CACHE_FILE) then
            local content = readfile(CACHE_FILE)
            return HttpService:JSONDecode(content)
        end
    end)
    
    if success and result then
        return result
    end
    
    return nil
end

local function saveCache(data)
    if not writefile then
        return false
    end
    
    local success = pcall(function()
        local json = HttpService:JSONEncode(data)
        writefile(CACHE_FILE, json)
    end)
    
    return success
end

local function updateCacheCount(clientId)
    local cache = loadCache() or {}
    
    if not cache[clientId] then
        cache[clientId] = {
            count = 0,
            lastCheck = os.time(),
            preferRAW = false,
            validated = false
        }
    end
    
    cache[clientId].count = cache[clientId].count + 1
    cache[clientId].lastCheck = os.time()
    
    if cache[clientId].count >= GITHUB_CHECK_LIMIT then
        cache[clientId].count = 0
        cache[clientId].preferRAW = false
    end
    
    saveCache(cache)
    
    return cache[clientId]
end

local function setValidated(clientId, value)
    local cache = loadCache() or {}
    
    if not cache[clientId] then
        cache[clientId] = {
            count = 0,
            lastCheck = os.time(),
            preferRAW = false,
            validated = value,
            accessDenied = false
        }
    else
        cache[clientId].validated = value
    end
    
    saveCache(cache)
end

local function setAccessDenied(clientId, value)
    local cache = loadCache() or {}
    
    if not cache[clientId] then
        cache[clientId] = {
            count = 0,
            lastCheck = os.time(),
            preferRAW = false,
            validated = false,
            accessDenied = value
        }
    else
        cache[clientId].accessDenied = value
    end
    
    saveCache(cache)
end

local function setPreferRAW(clientId, value)
    local cache = loadCache() or {}
    
    if not cache[clientId] then
        cache[clientId] = {
            count = 0,
            lastCheck = os.time(),
            preferRAW = value,
            validated = false
        }
    else
        cache[clientId].preferRAW = value
    end
    
    saveCache(cache)
end

local function getCacheData(clientId)
    local cache = loadCache()
    
    if not cache or not cache[clientId] then
        return {
            count = 0,
            preferRAW = false,
            validated = false
        }
    end
    
    return cache[clientId]
end

local function resetCache(clientId)
    local cache = loadCache() or {}
    cache[clientId] = {
        count = 0,
        lastCheck = os.time(),
        preferRAW = false,
        validated = false
    }
    saveCache(cache)
end

-- Validation
local function validateKey(key, clientId)
    local rateLimitOk, rateLimitMsg = checkRateLimit()
    if not rateLimitOk then
        Fluent:Notify({
            Title = "⚠️ Rate Limit",
            Content = rateLimitMsg,
            Duration = 5
        })
        return false
    end
    
    if not performTamperCheck() then
        Fluent:Notify({
            Title = "⚠️ Security Warning",
            Content = "Tampering detected. Please restart.",
            Duration = 5
        })
        return false
    end
    
    Fluent:Notify({
        Title = "🔒 Key Validation",
        Content = "Validating your key...",
        Duration = 3
    })
    
    local url = VALIDATION_API_URL .. "/api/roblox-validate-hwid?key=" .. HttpService:UrlEncode(key) .. "&hwid=" .. HttpService:UrlEncode(tostring(clientId))
    
    local success, response = pcall(function()
        return httpRequest({
            Url = url,
            Method = "GET"
        })
    end)
    
    if not success then
        VALIDATION_STATE.failedAttempts = VALIDATION_STATE.failedAttempts + 1
        Fluent:Notify({
            Title = "❌ Validation Failed",
            Content = "Request failed: Network error",
            Duration = 5
        })
        return false
    end
    
    local responseBody = response.Body or response
    local parseSuccess, data = pcall(function()
        return HttpService:JSONDecode(responseBody)
    end)
    
    if parseSuccess and data and data.success then
        VALIDATION_STATE.sessionToken = generateSessionToken(clientId)
        VALIDATION_STATE.authenticated = true
        VALIDATION_STATE.lastValidation = os.time()
        VALIDATION_STATE.failedAttempts = 0
        
        Fluent:Notify({
            Title = "✅ Success",
            Content = "Key validated successfully!",
            Duration = 3
        })
        
        pcall(function()
            httpRequest({
                Url = VALIDATION_API_URL .. "/api/add-client-to-github",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = HttpService:JSONEncode({
                    clientId = clientId
                })
            })
        end)
        
        setValidated(clientId, true)
        saveKey(key)
        return true
    else
        VALIDATION_STATE.failedAttempts = VALIDATION_STATE.failedAttempts + 1
        
        if VALIDATION_STATE.failedAttempts >= 5 then
            Fluent:Notify({
                Title = "🔒 Locked Out",
                Content = "Too many failed attempts. Wait 5 minutes.",
                Duration = 10
            })
            wait(300)
            VALIDATION_STATE.failedAttempts = 0
        end
        
        Fluent:Notify({
            Title = "❌ Validation Failed",
            Content = "Invalid key or HWID",
            Duration = 5
        })
        return false
    end
end

-- Fetch functions
local function fetchWithRetry(url, retries, serviceName)
    local attempts = 0
    local lastError = nil
    
    while attempts < retries do
        attempts = attempts + 1
        
        local cacheBuster = generateCacheBuster()
        local separator = url:find("?") and "&" or "?"
        local finalUrl = url .. separator .. "cb=" .. cacheBuster
        
        local success, response = pcall(function()
            if type(game.HttpGet) == "function" then
                return game:HttpGet(finalUrl, true)
            else
                return HttpService:GetAsync(finalUrl, true)
            end
        end)
        
        if success and response and #tostring(response) > 0 then
            return true, tostring(response), attempts
        else
            lastError = tostring(response)
            if attempts < retries then
                wait(RETRY_DELAY)
            end
        end
    end
    
    return false, lastError, attempts
end

local function parseWhitelistEntry(line)
    local parts = {}
    for part in line:gmatch("[^|]+") do
        table.insert(parts, trim(part))
    end
    
    if #parts >= 3 then
        return {
            encryptedId = parts[1],
            plainId = parts[2],
            timestamp = parts[3],
            raw = line
        }
    elseif #parts == 1 then
        return {
            encryptedId = parts[1],
            plainId = nil,
            timestamp = nil,
            raw = line
        }
    end
    
    return nil
end

local function checkPipeFormat(encryptedClientId, plainClientId, content)
    local lineNum = 0
    
    for line in content:gmatch("[^\r\n]+") do
        lineNum = lineNum + 1
        local trimmed = trim(line)
        if trimmed ~= "" then
            local entry = parseWhitelistEntry(trimmed)
            if entry then
                if entry.encryptedId == encryptedClientId then
                    return true, {
                        lineNumber = lineNum,
                        entry = entry,
                        matchType = "encrypted"
                    }
                end
                
                if entry.plainId and entry.plainId == plainClientId then
                    return true, {
                        lineNumber = lineNum,
                        entry = entry,
                        matchType = "plaintext"
                    }
                end
            end
        end
    end
    
    return false, nil
end

local function checkSimpleFormat(encryptedClientId, plainClientId, content)
    local lineNum = 0
    
    for line in content:gmatch("[^\r\n]+") do
        lineNum = lineNum + 1
        local trimmed = trim(line)
        if trimmed ~= "" then
            if trimmed == encryptedClientId then
                return true, {
                    lineNumber = lineNum,
                    value = trimmed,
                    matchType = "encrypted"
                }
            end
            
            if trimmed == plainClientId then
                return true, {
                    lineNumber = lineNum,
                    value = trimmed,
                    matchType = "plaintext"
                }
            end
        end
    end
    
    return false, nil
end

local function fetchFromGitHubAPI(repo, path, branch, retries)
    local attempts = 0
    local lastError = nil
    local apiUrl = string.format("https://api.github.com/repos/%s/contents/%s?ref=%s", repo, path, branch)
    
    while attempts < retries do
        attempts = attempts + 1
        
        local cacheBuster = generateCacheBuster()
        local finalUrl = apiUrl .. "&cb=" .. cacheBuster
        
        local ok, resp = pcall(function()
            if type(game.HttpGet) == "function" then
                return game:HttpGet(finalUrl, true)
            else
                return HttpService:GetAsync(finalUrl, true)
            end
        end)
        
        if ok and resp and #tostring(resp) > 0 then
            local decodeOk, jsonData = pcall(function()
                return HttpService:JSONDecode(resp)
            end)
            
            if decodeOk and jsonData and jsonData.content then
                local content = base64Decode(jsonData.content:gsub("\n", ""))
                return true, content, attempts, jsonData.sha
            else
                lastError = "Failed to decode JSON or missing content field"
            end
        else
            lastError = tostring(resp)
        end
        
        if attempts < retries then
            wait(RETRY_DELAY)
        end
    end
    
    return false, lastError, attempts, nil
end

local function fetchFromRawGitHub(rawUrl, retries)
    return fetchWithRetry(rawUrl, retries, "GitHub RAW")
end

local function checkGitHubAPI(encryptedClientId, plainClientId)
    local success, content, attempts, sha = fetchFromGitHubAPI(
        GITHUB_REPO,
        GITHUB_SOURCE.filePath,
        GITHUB_BRANCH,
        MAX_RETRIES
    )
    
    if not success then
        return false, nil
    end
    
    local firstLine = content:match("[^\r\n]+")
    local isPipeFormat = firstLine and firstLine:find("|", 1, true)
    
    local found, data
    if isPipeFormat then
        found, data = checkPipeFormat(encryptedClientId, plainClientId, content)
    else
        found, data = checkSimpleFormat(encryptedClientId, plainClientId, content)
    end
    
    if found then
        return true, {
            source = "github_api",
            data = data
        }
    end
    
    return false, nil
end

local function checkGitHubRAW(encryptedClientId, plainClientId)
    local success, content, attempts = fetchFromRawGitHub(GITHUB_SOURCE.rawUrl, MAX_RETRIES)
    
    if not success then
        return false, nil
    end
    
    local firstLine = content:match("[^\r\n]+")
    local isPipeFormat = firstLine and firstLine:find("|", 1, true)
    
    local found, data
    if isPipeFormat then
        found, data = checkPipeFormat(encryptedClientId, plainClientId, content)
    else
        found, data = checkSimpleFormat(encryptedClientId, plainClientId, content)
    end
    
    if found then
        return true, {
            source = "github_raw",
            data = data
        }
    end
    
    return false, nil
end

local function checkHWIDAPI(encryptedClientId, plainClientId)
    local success, response, attempts = fetchWithRetry(HWID_API_URL, MAX_RETRIES, "HWID API")
    
    if not success then
        return false, nil, "access_denied"
    end
    
    local decodeSuccess, data = pcall(function()
        return HttpService:JSONDecode(response)
    end)
    
    if not decodeSuccess or not data or not data.success then
        return false, nil, "access_denied"
    end
    
    local hwids = data.hwids or {}
    
    for i, encryptedHWID in ipairs(hwids) do
        local decryptSuccess, decryptedHWID = pcall(function()
            return decrypt(encryptedHWID, MASTER_KEY)
        end)
        
        if decryptSuccess then
            if decryptedHWID == plainClientId or decryptedHWID == encryptedClientId then
                return true, {
                    source = "hwid_api",
                    index = i
                }, nil
            end
        end
    end
    
    return false, nil, "access_denied"
end

-- Main whitelist check
local function isClientIdWhitelisted(clientId, encryptedClientId)
    if not performTamperCheck() then
        warn("⚠️ Tampering detected during whitelist check")
        return false, nil, "tamper_detected"
    end
    
    local cacheData = getCacheData(clientId)
    
    if SHOW_STATS then
        print(cacheData.count .. "/" .. GITHUB_CHECK_LIMIT)
    end
    
    local updatedCache = updateCacheCount(clientId)
    
    -- CYCLE 0: Check HWID API ONLY
    if cacheData.count == 0 then
        local apiFound, apiData, errorType = checkHWIDAPI(encryptedClientId, clientId)
        
        if errorType == "access_denied" then
            return false, nil, "access_denied"
        end
        
        if apiFound then
            return true, apiData, nil
        end
    
    -- CYCLE 8: Mid-cycle HWID API check
    elseif cacheData.count == HWID_API_CHECK_INTERVAL then
        local apiFound, apiData, errorType = checkHWIDAPI(encryptedClientId, clientId)
        
        if errorType == "access_denied" then
            return false, nil, "access_denied"
        end
        
        if apiFound then
            return true, apiData, nil
        end
    end
    
    -- GitHub checks ONLY if not access_denied
    if cacheData.preferRAW then
        local githubRAWFound, githubRAWData = checkGitHubRAW(encryptedClientId, clientId)
        if githubRAWFound then
            return true, githubRAWData, nil
        end
        
        setPreferRAW(clientId, false)
        local githubAPIFound, githubAPIData = checkGitHubAPI(encryptedClientId, clientId)
        if githubAPIFound then
            return true, githubAPIData, nil
        end
    else
        local githubAPIFound, githubAPIData = checkGitHubAPI(encryptedClientId, clientId)
        if githubAPIFound then
            setPreferRAW(clientId, true)
            return true, githubAPIData, nil
        end
        
        if USE_FALLBACK_API then
            local githubRAWFound, githubRAWData = checkGitHubRAW(encryptedClientId, clientId)
            if githubRAWFound then
                return true, githubRAWData, nil
            end
        end
    end
    
    -- Cycle complete - recheck HWID API
    if updatedCache.count >= GITHUB_CHECK_LIMIT then
        local apiFound, apiData, errorType = checkHWIDAPI(encryptedClientId, clientId)
        
        if errorType == "access_denied" then
            return false, nil, "access_denied"
        end
        
        if apiFound then
            return true, apiData, nil
        end
    end
    
    return false, nil, "access_denied"
end

-- Session monitoring
local function startSessionMonitoring(clientId)
    spawn(function()
        while VALIDATION_STATE.authenticated do
            wait(30)
            
            if os.time() - VALIDATION_STATE.lastValidation > 86400 then
                warn("⚠️ Session expired. Revalidation required.")
                VALIDATION_STATE.authenticated = false
                deleteKey()
                break
            end
            
            if not performTamperCheck() then
                warn("⚠️ Tampering detected. Session invalidated.")
                VALIDATION_STATE.authenticated = false
                deleteKey()
                break
            end
        end
    end)
end

-- Main execution
VALIDATION_STATE.sessionToken = generateSessionToken("init")

local clientId = tostring(RbxAnalytics:GetClientId() or "")
if clientId == "" then
    return {
        success = false,
        error = "No Client ID"
    }
end

local encryptedClientId = encrypt(clientId, MASTER_KEY)

-- Check whitelist
local whitelisted, matchData, errorType = isClientIdWhitelisted(clientId, encryptedClientId)

-- Show GUI if access denied or tampering detected
if not whitelisted or errorType == "access_denied" or errorType == "tamper_detected" then
    local Window = Fluent:CreateWindow({
        Title = "🔒 HWID Validation System",
        SubTitle = "by Your Security Team",
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true,
        Theme = "Dark",
        MinimizeKey = Enum.KeyCode.LeftControl
    })
    
    local Tabs = {
        Main = Window:AddTab({ Title = "Validation", Icon = "key" })
    }
    
    local validationComplete = false
    local validationSuccess = false
    
    -- HWID Display
    Tabs.Main:AddParagraph({
        Title = "Your HWID",
        Content = clientId
    })
    
    Tabs.Main:AddParagraph({
        Title = "Status",
        Content = "⛔ Your HWID is not whitelisted. Please enter your validation key below."
    })
    
    -- Check for saved key
    local savedKey = loadKey()
    local keyInputValue = savedKey or ""
    
    -- Key Input
    local KeyInput = Tabs.Main:AddInput("KeyInput", {
        Title = "Validation Key",
        Default = keyInputValue,
        Placeholder = "Enter your key here...",
        Numeric = false,
        Finished = false,
        Callback = function(value)
            keyInputValue = value
        end
    })
    
    -- Validate Button
    Tabs.Main:AddButton({
        Title = "✓ Validate Key",
        Description = "Click to validate your key",
        Callback = function()
            local key = trim(keyInputValue)
            
            if key == "" then
                Fluent:Notify({
                    Title = "⚠️ Empty Key",
                    Content = "Please enter a validation key",
                    Duration = 3
                })
                return
            end
            
            local success = validateKey(key, clientId)
            
            if success then
                validationSuccess = true
                validationComplete = true
                
                wait(2)
                Window:Destroy()
            end
        end
    })
    
    -- Copy HWID Button
    Tabs.Main:AddButton({
        Title = "📋 Copy HWID",
        Description = "Copy your HWID to clipboard",
        Callback = function()
            setclipboard(clientId)
        end
    })
    
    -- Close Button
    Tabs.Main:AddButton({
        Title = "✕ Close",
        Description = "Exit validation",
        Callback = function()
            Window:Destroy()
        end
    })
    
    -- Wait for validation completion
    local timeout = 300
    local elapsed = 0
    while not validationComplete and elapsed < timeout do
        wait(1)
        elapsed = elapsed + 1
    end
    
    if validationSuccess then
        wait(2)
        
        resetCache(clientId)
        
        whitelisted, matchData, errorType = isClientIdWhitelisted(clientId, encryptedClientId)
        
        if whitelisted then
            startSessionMonitoring(clientId)
            
            return {
                success = true,
                whitelisted = true,
                matchData = matchData,
                validated = true,
                sessionToken = VALIDATION_STATE.sessionToken
            }
        else
            return {
                success = false,
                error = "not_whitelisted_after_validation"
            }
        end
    else
        return {
            success = false,
            error = "validation_cancelled"
        }
    end
end

-- Normal whitelist result
if whitelisted then
    startSessionMonitoring(clientId)
    
    return {
        success = true,
        whitelisted = true,
        matchData = matchData,
        sessionToken = VALIDATION_STATE.sessionToken
    }
else
    return {
        success = false,
        whitelisted = false
    }
end
